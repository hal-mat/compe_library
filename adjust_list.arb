# ref:https://atcoder.jp/contests/abc291/submissions/39282338
require 'set'

# set必須なので注意
module AdjustList
  def adjust_list(min_nodes_count = 0)
    buffer_answer = Array.new(min_nodes_count)
    # buffer_answer = {}
    each do |node_a, node_b|
      node_a -= 1
      node_b -= 1
      # buffer_answer[node_a] ||= []
      buffer_answer[node_a] ||= [].to_set
      buffer_answer[node_a] << node_b
      # buffer_answer[node_b] ||= []
      buffer_answer[node_b] ||= [].to_set
      buffer_answer[node_b] << node_a
    end
    buffer_answer
  end

  def single_adjust_list(min_nodes_count = 0)
    buffer_answer = Array.new(min_nodes_count)
    each do |node_a, node_b|
      node_a -= 1
      node_b -= 1
      buffer_answer[node_a] ||= [].to_set
      buffer_answer[node_a] << node_b
    end
    buffer_answer
  end

  # トポロジカルソートに使う。ref:https://atcoder.jp/contests/abc291/submissions/39401286
  def reverse_adjust_list(min_nodes_count = 0)
    buffer_answer = Array.new(min_nodes_count)
    each do |node_a, node_b|
      node_a -= 1
      node_b -= 1
      buffer_answer[node_b] ||= [].to_set
      buffer_answer[node_b] << node_a
    end
    buffer_answer
  end

  # ufと違い片方向のみの場合のtree_size。2000*2000くらいなら通る。自分も含むので注意
  # ref:https://atcoder.jp/contests/abc292/submissions/39754461
  module CanVisitNodesCountFrom
    def can_visit_nodes_count_from(root = 0)
      stack = [root]
      visited = [].to_set
      while (tmp_node = stack.pop)
        next if visited.include?(tmp_node)

        visited << tmp_node
        stack.concat self[tmp_node].to_a if self[tmp_node]
      end
      visited.size
    end
  end

  # warshall_floydで通らなさそうな2000*2000ではこちらを使う。
  # AdjustListでsetを使っている場合は通らないので配列に直す
  # ref:https://atcoder.jp/contests/abc299/submissions/40885238
  module BfsAdjustMatrix
    def bfs_adjust_matrix(nodes_count)
      answer = []
      nodes_count.times do |start_node|
        answer << bfs_from(start_node)
      end
      answer
    end

    def bfs_from(start_node)
      answer = bfs_first_answer(start_node)
      queue = [start_node]
      while (tmp_node = queue.shift) && (tmp_step = answer[tmp_node])
        (self[tmp_node] || []).each do |adj_node|
          next if answer[adj_node]

          answer[adj_node] = tmp_step + 1
          queue << adj_node
        end
      end
      answer
    end

    def bfs_first_answer(start_node)
      answer = []
      answer[start_node] = 0
      answer
    end
    private :bfs_from, :bfs_first_answer
  end
end

EDGES.extend AdjustList
ADJ_LIST = EDGES.adjust_list
p ADJ_LIST if debug
