# 空配列にいちいちheap_pushすると重いので、heap_pushが必要になってからsortして使う
module MyHeap
  # https://qiita.com/k-penguin-sato/items/7f98335ef631ea5ce7ad
  # 使えるかわからんので注意
  @correct_order_proc = nil
  def write_proc!(&arg_block)
    @correct_order_proc = arg_block
    @correct_order_proc.freeze
  end

  def heap_push!(arg_value)
    self << arg_value
    # 昔はここからのせり上がりを再帰関数で書いていたが、rubyはwhileで書かないと間に合わない
    # 1-indexedなら2で割るだけで親インデックスが出るのだが、shiftがややこしくなりそうなのであえて0-indexed
    child_index = size - 1
    # https://atcoder.jp/contests/abc252/submissions/31865081
    # マジで一回ずつswapするのではなく、既存のピラミッドを一段ずつ引き下げて出来た隙間に引数の要素をねじ込む
    parent_index = parent_index_of(child_index)
    parent_value = self[parent_index]
    until @correct_order_proc.call(parent_value, arg_value) || child_index == 0
      # 親の値を子の位置に引き下げ、もう一段上で再比較
      self[child_index] = parent_value
      child_index = parent_index
      parent_index = parent_index_of(child_index)
      parent_value = self[parent_index]
    end
    # それ以上上がれない場合は末尾の値を現在のchildの位置にねじ込んで終了
    self[child_index] = arg_value
  end

  def heap_shift!
    if size <= 2
      shift
    else
      shift_value = self[0]
      self[0] = pop
      heap_down!
      shift_value
    end
  end

  def heap_swap!(arg)
    self[0] = arg
    heap_down!
  end

  private

  def parent_index_of(child_index)
    (child_index - 1) >> 1
  end

  # AtCoder Libraryのup,downと逆なので注意。下から持ち上げるのがup,頂上から下ろすのがdown
  def heap_down!
    # 昔は再帰関数で書いていたが、rubyはwhileで書かないと間に合わない
    # 1-indexedなら2倍すれば左の子インデックスになるが、shiftがややこしいので0-indexed
    # マジで一回ずつswapするのではなく、既存のピラミッドを一段ずつ引き下げて出来た隙間に引数の要素をねじ込む
    first_value = self[0]

    tmp_parent_index = 0

    # must_parent_indexが親のindexのまま→正位置。終了
    # must_parent_indexに子のindexが再代入→転倒。子の値を親の位置に引き上げ、もう一段下で再比較
    until (must_parent_index = must_parent_index_of(first_value, tmp_parent_index)) == tmp_parent_index
      # 子の値を親の位置に引き上げ、もう一段下で再比較
      self[tmp_parent_index] = self[must_parent_index]
      tmp_parent_index = must_parent_index
    end
    # 終了したら頂上の値を今の親のindexに代入
    self[tmp_parent_index] = first_value
  end

  def left_child_index_of(parent_index)
    (parent_index << 1) + 1
  end

  def must_parent_index_of(parent_value, parent_index)
    # indexから実際の値を取ってこないこと。実際に値を交換せずに擬似的に親valueを下ろしてきているだけなのでズレる
    left_child_index = left_child_index_of(parent_index)
    return parent_index unless self[left_child_index]

    right_child_index = left_child_index + 1
    # 子の値はズレていないので直接取って良し。左と右どちらが親に近いか決める
    stronger_child_index = if !self[right_child_index] || @correct_order_proc.call(self[left_child_index],
                                                                                   self[right_child_index])
                             left_child_index
                           else
                             right_child_index
                           end
    # 勝ち残った方の子を親と比べる
    @correct_order_proc.call(parent_value, self[stronger_child_index]) ? parent_index : stronger_child_index
  end
end

heap = []
heap.extend MyHeap
heap.write_proc! { |a, b| a < b }
